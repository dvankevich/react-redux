Робота з бібліотекою **redux-persist** дозволяє автоматично зберігати стан вашого Redux-сховища у `localStorage` (або іншому сховищі) та відновлювати його після перезавантаження сторінки.

На основі вашого коду, ось детальні пояснення кожного етапу інтеграції.

---

## 1. Конфігурація Store (`src/redux/store.js`)

У вашому поточному файлі `store.js` ви використовуєте `configureStore` для об'єднання `tasksReducer` та `filtersReducer`. Для підключення персистенції потрібно змінити логіку створення редюсерів.

### Основні поняття:

* **`persistReducer`**: функція-обгортка, яка приймає конфігурацію та ваш звичайний редюсер, додаючи йому логіку збереження.
* **`storage`**: об'єкт, який вказує, куди саме записувати дані (за замовчуванням — `window.localStorage`).
* **`persistStore`**: функція, яка створює об'єкт-персистор для синхронізації сховища.

### Чому ми ігноруємо Middleware?

Redux Toolkit за замовчуванням перевіряє, щоб усі дані в екшенах були серіалізованими (простими рядками або об'єктами). Оскільки `redux-persist` використовує спеціальні внутрішні екшени (`FLUSH`, `REHYDRATE` тощо), які містять несеріалізовані дані, нам потрібно вимкнути цю перевірку для конкретних типів екшенів, щоб уникнути помилок у консолі.

---

## 2. Вибіркове збереження (Whitelist/Blacklist)

У вашому проєкті є два типи даних: завдання (`tasks`) та фільтри (`filters`).

* **Завдання** варто зберігати, щоб користувач не втратив список справ.
* **Фільтри** (активні/виконані) зазвичай не зберігають, щоб при новому вході користувач бачив повний список.

Тому найкраща стратегія — обернути в `persistReducer` лише `tasksReducer`, а `filtersReducer` залишити без змін.

---

## 3. Оновлення точки входу (`src/main.jsx`)

Зараз ваш застосунок рендериться миттєво через `Provider`. При використанні `redux-persist` виникає невелика затримка, поки дані зчитуються з `localStorage`.

### Компонент `PersistGate`

Цей компонент служить "запобіжником":

1. Він призупиняє рендер інтерфейсу (`App`) до того моменту, поки стан не буде успішно завантажений із локального сховища.
2. Ви можете передати проп `loading`, наприклад, спінер або `null`, який буде відображатися під час цього процесу.

---

## Практичні поради для вашого репозиторію

1. **Початковий стан:** Оскільки ваш `initialState` у `tasksSlice.js` — це порожній масив `[]`, бібліотека автоматично замінить його даними з `localStorage`, якщо вони там є.
2. **Унікальні ключі:** У конфігурації `key: 'root'` або `key: 'tasks'` — це назва ключа, під яким дані будуть лежати в інструментах розробника браузера.
3. **Міграції:** Якщо ви пізніше зміните структуру об'єкта завдання в `tasksSlice.js` (наприклад, додасте поле `priority`), дані в `localStorage` старого формату можуть викликати помилки. У такому разі потрібно або змінити версію в конфігурації, або вручну очистити `localStorage`.

---

### Резюме дій:

* Встановіть пакет: `npm install redux-persist`.
* У `store.js` налаштуйте `persistReducer` для завдань та створіть `persistor`.
* У `main.jsx` оберніть `App` у `PersistGate`.

